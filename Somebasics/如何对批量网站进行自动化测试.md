# 1.网站性能好坏的影响
最直观的体现在所需功能是否满足、用起来是否响应快、界面是否好看、是否符合其操作习惯
快不快就是性能的体现，性能分为前端性能和后端性能，先讨论前端性能
有数据表明性能在一定程度上和公司的收益直接相关  
![性能与收益的关系](/Somebasics/images/如何1.png)  

# 2.网页加载过程
输入网址：在浏览器中输入URL或点击链接（一般都是域名）  
解析域名：浏览器连接到DNS（域名解析系统）将域名解析为对应的IP地址  
建立连接：与这个IP地址确定的那台服务器建立TCP网络连接（三次握手）  
发送请求：随后向服务端发送HTTP请求  
接收响应：服务端处理完请求后，将数据放在HTTP响应里返回给客户端  
关闭连接：数据发送完毕之后，关闭TCP连接（四次挥手）  
渲染页面：浏览器解析模型（HTML&CSS）、渲染页面（布局、绘制）  
页面显示：渲染完毕之后，页面呈现给用户，并时刻等待响应用户的操作  
# 3.输入网址之后，用户可感知过程
1、显示白屏：从屏幕空白到第一个画面出来  
2、首次有内容显示：页面在首次有内容显示出来  
3、显示部分内容：页面中显示部分内容  
4、页面可操作：页面中所有内容都显示出来，并且可以进行正常操作  
**如何衡量这些指标好不好**：  
1、参考业界标准：以业界标准的指标作为参考，跟业界对其；  
2、参考竞品的数据：以竞品的性能指标作为参考向对手学习；  
3、参考监控的数据：采集用户的前端性能数据作为参考  
![常见的衡量指标](/Somebasics/images/如何2.png)  
# 4.确定关注性能指标

- 1、白屏时间（FirstPaint,FP）：从屏幕空白到第一个画面出来的时间  
- 2、首次内容渲染时间（FirstContentful Paint,FCP）:渲染出受干扰文本或图片的时间  
- 3、最大内容绘制时间（Largest Contentful Paint,LCP）:渲染出最大文本或图片的时间  
- 4、可交互时间（Time To Interactive,TTI）:网页需要多长时间才能提供完整交互功能  
- 5、页面请求数、图片大小、文件是否压缩、是否使用CDN等潜在影响因素  
# 5.由此可以指定自己的产品性能指标
![常见的指标耗时及说明](/Somebasics/images/如何3.png)
## 5.1 什么是DOM
DOM是文档对象模型，是W3C制定的标准接口规范，是一种处理HTML和XML文件的标准API。DOM提供了对整个文档的访问模型，将文档作为一个树形结构，树的每个结点表示了一个HTML标签或标签内的文本项。DOM树结构精确地描述了HTML文档中标签地相互关联性。将HTML或XML文档转化为DOM树地过程称为解析（parse）。HTML文档被解析之后，转化为DOM树，因此对HTML文档地处理可以通过对DOM树的操作实现。DOM模型不仅描述了文档的结构，还定义了结点对象的行为，利用对象的方法和属性，可以方便的访问、修改、添加和删除DOM树的结点和内容。  
### 5.1.1 关键字
元素（element）:文档中的所有标签都是元素，元素可以看成是对象  
节点：文档中所有内容都是节点，标签属性文本等  
文档（document）：一个页面就是一个文档  
这三者的关系是：文档包含节点，节点包含元素  
### 5.1.2 D（document）文档
一个页面就是一个文档，一个html文件或xml文件就是一个文档，两者的区别是html用来展示信息数据的，xml侧重于存储数据。
### 5.1.3 Object对象
万物皆对象
### 5.1.4 Model模型
文档（页面）中有一个根(root)，这个标签包含head标签和body标签，head标签中又包含meta和title标签，body标签中包含div、p、header、main等等标签，其中main下面又有article、aside等等标签，article标签中又有其他标签等待，这就组成了树状结构图，也叫DOM树。这就形成了一个模型
![什么是DOM树？你了解DOM树吗？](/Somebasics/images/如何4.png)  
### 5.1.5 Node节点
Node节点包含了标签、属性、文本等，定义了节点对象的行为，就是利用对象的方法和属性，可以方便的访问、修改、添加和删除DOM树的结点和内容。
### 5.1.6 DOM的作用
让javascript可以对文档中的标签、属性、内容等进行增删改查操作  
```python
html内容
<div>我是div元素</div>
<p id="p">我是p元素</p>

访
var div = document.getElementsByTagName('div')
var p = document.getElementById('p')

增
// 创建一个a元素
var a = document.createElement('a')
// 添加到body
document.body.append(a)

删
// 移除body中的div子节点
document.body.removeChild(div)

改
div.innerHTML = '我修改了div的文本内容'

```
### 5.1.7 TBT
TBT：为了清楚地理解这些，让我们看一个例子。如果主线程要执行四个任务，每个任务所花费的时间如下：  

任务 1 ——58 毫秒。  
任务 2 ——45 毫秒。  
任务 3 ——125 毫秒。  
任务 4 ——200 毫秒。  
那么阻塞时间，即50ms后执行每个任务所花费的时间，为：  

任务 1 ——8 毫秒。  
任务 2 ——0 毫秒。  
任务 3 ——75 毫秒。  
任务 4 ——150 毫秒。  
这个网页的总阻塞时间将是每个任务的阻塞时间的总和，即 8 + 0 + 75 + 150 = 233 ms，根据 Lighthouse 的评级，这是一个网页的好分数，因为它小于 300 毫秒。  

主线程上的少量任务并不一定意味着低阻塞时间。相反，大量的任务并不一定会导致大量的阻塞时间或糟糕的用户体验。  

注意：请记住，只有50ms以上的时间才被认为是阻塞时间。  
当任务长度超过 50 毫秒时，它是首次内容绘制 (FCP) 和交互时间 (TTI) 之间的所有时间段的总和。 

TBT听起来就像是Time To Interactive(TTI)。但是，虽然相似，但这两个指标最终衡量的是不同的事物。  

TTI告诉您页面完全交互需要多长时间，以秒为单位。要被认为是交互式的，页面必须显示有用的内容并在不到50毫秒的时间内响应用户输入。此外，必须为大多数页面元素注册事件处理程序。  

总阻塞时间TBT是当访问者在此期间尝试与页面交互时，会出现延迟，因为主线程很忙。TBT有助于量化这些延误的严重程度，让您详细了解交互性受长任务影响的严重程度，而不是指出页面何时变为交互性。    
![页面](/Somebasics/images/如何5.png)  
## 5.2各类指标
### 5.2.1 FCP
First Contentful Paint（FCP）:从页面开始加载-到-页面内容的任何部分在屏幕上都呈现出来的时间。此内容可能包含文本、图像、SVG或任何其他可见的元素。FCP以毫秒为单位，从页面开始加载时开始计算，FCP越低，用户体验越好，通常FCP小于2S，以获得最佳性能。FID（首次输入延迟）和FCP通常一起使用来评估网页变得具有交互性的速度。LCP是绘制最大内容物的时间。FCP是侧重于初始加载阶段，LCP关注主要内容。  

如何提高FCP：  
1、优化关键渲染路径：通过最小化渲染阻塞的JavaScript和CSS，确保浏览器可以尽快渲染第一段内容  
2、延迟加载：在显示初始内容后加载非关键资源，如图片和视频  
3、使用内容分发网络（CDN）：从离用户更近的位置提供内容可以减少加载资源所需的时间，从而提高FCP  
4、最小化主线程工作：减少在加载过程中执行的JavaScript量有助于加快FCP  
### 5.2.2 FID
First Input Delay（FID）：首次输入延迟，关键的 Web 性能指标，用于衡量从用户首次与您的网站交互（例如，点击链接、点击按钮或使用自定义 JavaScript 驱动的控件）到浏览器实际能够开始处理该事件的时间。需要注意的是，FID 仅捕获响应第一次用户交互的延迟;它不测量完全处理事件所需的时间。
FID 以毫秒 （ms） 为单位。Google 建议 FID 应小于 100 毫秒，以确保良好的用户体验。由于 FID 仅测量第一次交互的延迟，因此它在页面加载阶段尤其相关，此时浏览器可能正忙于解析 HTML、加载和执行 JavaScript 等其他任务。  
影响FID的因素：  
大量 JavaScript 执行：当主线程忙于执行 JavaScript 时，它无法响应用户交互，从而导致高 FID。
长任务：如果浏览器忙于处理需要很长时间才能完成的任务（通常超过 50 毫秒），则无法响应用户输入，从而导致延迟。  
阻止渲染的资源：阻止渲染的 CSS 和 JavaScript 文件也可能会延迟浏览器响应交互的能力。  

如何改善 FID：  
优化 JavaScript 执行：  
最小化 JavaScript：减少需要处理的 JavaScript 量，尤其是在页面加载期间。  
代码拆分：将 JavaScript 分解为更小的块，这些块可以根据需要加载，而不是一次加载所有块。  

减少第三方代码的影响：  

来自第三方的脚本（如广告或社交媒体小部件）有时会阻止主线程。尽可能最小化或推迟第三方脚本。

使用 Web Worker：  
使用 Web Worker 将复杂的计算卸载到后台线程，从而释放主线程以更快地处理用户交互。  

延迟非关键 JavaScript：
推迟不是立即需要的 JavaScript，这样它就不会在初始加载期间阻塞主线程。  

确定用户交互的优先级：
确保用户交互优先于其他任务。这可以通过拆分长任务并定期将控制权交还给浏览器来完成。  
### 5.2.3 Speed Index
衡量在页面加载过程中显示网页的可见部分所需的时间。它计算首屏内容（页面中不滚动而可见的部分）在视觉上完成的速度。速度指数越低，感知到的性能越好，因为这意味着内容显示得更快。  
### 5.2.4 TTI
Time To Interactive（TTI）交互时间：衡量网页完全交互所需的时间。当页面完成呈现最重要的内容，为大多数可见元素注册事件处理程序，并且页面快速可靠地响应用户输入时，该页面被视为“交互式”。  

TTI是如何计算的：  
TTI 是通过监控页面加载过程并确定页面变得可靠交互的点来计算的。这包括：
检测何时呈现最重要的内容（关键资源）。
确保没有长任务（耗时超过 50 毫秒的任务）阻塞主线程。
验证事件处理程序是否已就位，并且可以快速响应用户输入。
TTI 分数本质上是满足所有这些条件的时间点，表明页面已准备好进行全面交互。  

如何提高TTI：  
优化 JavaScript：  

最小化和延迟非关键 JavaScript：延迟或异步加载初始渲染不需要的 JavaScript，以更快地释放主线程。
代码拆分：将 JavaScript 分解为更小、更易于管理的块，这些块可以按需或在需要时加载。  

减少长时间的任务：  

将长时间运行的 JavaScript 任务分解为较小的部分，这些可以将控制权交还给浏览器，使其能够更快地处理用户交互。  

确定关键资源的优先级：  

确保尽早加载对交互性至关重要的资源。这可能包括优化 CSS、提前加载必要的 JavaScript 以及推迟不必要的资源。  

延迟加载：  

对图像、视频和其他非必要内容实施延迟加载，以便它们不会阻塞主线程。  

使用 Web Worker：  

将繁重的计算负担交给 Web Worker，Web Worker 在后台运行而不会阻塞主线程，从而使页面能够更快地交互。  

缩短服务器响应时间：  

优化服务器响应时间并使用内容分发网络 （CDN） 来确保资源快速加载，从而加快 TTI 的速度。  

### 5.2.5 FMP
First Meaningful Paint（FMP）首次有意义绘制：是一种 Web 性能指标，用于衡量页面的主要内容何时对用户可见。它侧重于页面中最重要的内容何时变得可见，标志着用户认为页面开始有用的点。  

提高 FMP：  
尽管 FMP 目前使用较少，但了解如何改进它作为整体性能优化的一部分仍然很有价值：  

优先考虑关键内容：  

确保首先呈现最重要的内容。这可能涉及优化资源加载的顺序，并减少渲染阻塞资源的影响。  
优化渲染路径：    

通过优化关键渲染路径，最大限度地减少浏览器开始绘制最有意义的内容所需的时间。  
减少渲染阻塞的 JavaScript 和 CSS：  

仅加载初始渲染所需的 JavaScript 和 CSS，并推迟其余部分以缩短渲染有意义内容所需的时间。  
对非关键内容使用延迟加载：  

对不需要立即显示的图像和其他媒体实施延迟加载技术，从而更快地加载有意义的内容。  
### 5.2.6 FCP
First CPU Idle（FCP）首次 CPU 空闲：“CPU 空闲”标记页面加载后的时间点，当主线程变得足够空闲时，它可以在合理的时间内（通常少于 50 毫秒）响应大多数用户输入。这并不意味着页面完全空闲，而是它对大多数交互的响应速度足够快。
该指标旨在评估页面何时具有最低限度的交互性，这意味着页面已达到可以快速响应大多数用户操作的状态，即使某些后台进程仍在运行。这对于确保用户可以与页面交互而不会遇到延迟或延迟非常重要。
第一个 CPU 空闲时间是从页面开始加载的那一刻起，以毫秒 （ms） 为单位来衡量的。它是通过识别主线程空闲足够长的时间以响应用户输入而不会出现明显延迟的第一个时刻来确定的。Google Lighthouse 和 WebPageTest 等工具可以衡量 First CPU 空闲时间，但值得注意的是，这个指标目前不太常用，因为它已经在很大程度上被交互时间 （TTI） 等更现代的指标所取代。  

如何提高首次 CPU 空闲率：  
优化 JavaScript：  
最小化和延迟 JavaScript：减少页面加载期间需要执行的 JavaScript 量可以帮助主线程更快地处于空闲状态。
代码拆分：将 JavaScript 分解为更小、更易于管理的块，这些块可以按需加载，而不是一次加载所有块。  
确定关键任务的优先级：  
确保对影响交互性的关键任务进行优先级排序，并将非必要任务推迟到页面加载之后。  
减少长时间的任务：  
将长时间运行的任务分解为较小的任务，这些任务将控制权交还给主线程，使其能够更快地处于空闲状态。  
延迟加载：  
对图像、视频和其他非必要内容实施延迟加载，以便它们在初始加载期间不会阻塞主线程。  
使用 Web Worker：  
将繁重的计算负担交给 Web Worker，这些 Web Worker 在后台运行而不会阻塞主线程，有助于减少 First CPU 空闲的时间。    

第一个 CPU 空闲与其他指标：  
First CPU 空闲与 TTI（交互时间）：TTI 是一个更全面的指标，用于衡量页面何时完全交互，而不仅仅是主线程何时空闲。TTI 考虑了整个用户体验，对于性能分析通常比首次 CPU 空闲更有用。  

First CPU Idle vs. FCP（First Contentful Paint）：FCP 测量何时呈现第一段内容，而 First CPU Idle 测量页面的响应速度何时变得足够快以处理用户交互。  

First CPU Idle vs. FMP（First Meaningful Paint）：FMP 关注主要内容何时变得可见，而 First CPU Idle 关注页面何时对用户输入做出响应。  

### 5.2.7 EIL
Estimated Input Latency（EIL）估计输入延迟：估计输入延迟衡量用户与网页交互与浏览器能够响应该交互之间的估计延迟。此指标以毫秒 （ms） 为单位表示，可直观地反映页面对用户的响应速度。
此指标的目的是让开发人员对页面的交互性有一个早期估计。它有助于确定用户在与页面交互时是否可能遇到延迟或延迟。估计的输入延迟越低，表示用户体验的响应速度越快、流畅度越高。
估计的输入延迟是通过分析浏览器主线程上的工作负载来计算的。如果主线程忙于执行 JavaScript 或处理其他任务，它将无法立即响应用户交互。该指标根据主线程的当前工作负载估计用户可能遇到的延迟程度。  

如何改善估计的输入延迟：  
优化 JavaScript：  
最小化和延迟非关键 JavaScript：通过减少页面加载期间需要执行的 JavaScript 数量，您可以释放主线程以更快地响应用户输入。
代码拆分：将 JavaScript 分解为更小的包，可以按需加载，从而减少主线程的初始负载。  
减少长时间的任务：  
将长时间运行的任务拆分为较小的块，使浏览器能够将控制权交还给主线程，从而使其能够更快地处理用户交互。  
延迟加载：  
对图片、视频和其他非必要资源实施延迟加载，以减少主线程的初始负载并缩短响应时间。  
使用 Web Worker：  
将繁重的计算或后台任务卸载给 Web Worker，使主线程能够保持对用户输入的响应。  
确定关键资源的优先级：  
确保尽早加载和执行关键资源，尤其是与交互性相关的资源，以最大程度地减少输入延迟。  

估计的输入延迟与其他指标：  
估计输入延迟与首次输入延迟 （FID）：FID 衡量页面上第一次交互期间经历的实际延迟，而估计输入延迟则根据主线程的负载提供页面可能响应程度的早期估计。  

估计输入延迟与 TTI（交互时间）：TTI 衡量页面何时完全交互并且能够在 50 毫秒内响应输入，而估计输入延迟则估计页面在达到完全交互性之前的响应能力。  

估计输入延迟与第一个 CPU 空闲：第一个 CPU 空闲衡量的是主线程何时变得足够空闲以处理用户输入，而估计输入延迟则根据当前主线程活动估计处理这些输入的延迟。  
### 5.2.8 CLS
Cumulative Layout Shift(CLS)累积布局偏移:通过跟踪布局在加载过程中的偏移程度来衡量网页的视觉稳定性。它量化了页面加载时 Web 元素的意外移动，这可能会对用户体验产生负面影响。
CLS 的目的是确保用户在与网页交互时不会遇到意外的内容变化。意外的布局变化可能会导致用户意外点击错误的元素或忘记他们正在查看的内容，从而导致令人沮丧的用户体验。
CLS 的计算方法是将页面生命周期内发生的所有意外布局偏移的分数相加。每个布局偏移分数是通过将影响分数乘以距离分数来确定的：
影响分数：受布局偏移影响的视口百分比。
距离分数：移动的元素相对于视口移动的距离。
单个布局偏移分数的公式为：布局偏移分数=冲击分数×距离分数
布局偏移分数=冲击分数×距离分数
CLS 分数是页面整个生命周期中所有这些单个分数的总和。  

如何减少 CLS：  
为图片和视频设置尺寸属性：  
始终在图像、视频和其他媒体元素上包含宽度和高度属性，以确保浏览器可以在内容加载之前分配正确的空间量。  
为广告和嵌入预留空间：  
使用 CSS 为广告、iframe 和其他嵌入内容预留空间，以避免在加载时布局发生变化。  
避免在现有内容上方插入内容：  
请谨慎对待动态注入的内容。将新内容放在首屏下方，或确保有足够的预留空间供其使用。  
使用字体显示选项：  
使用 or CSS 属性可防止由延迟加载 Web 字体引起的布局偏移。font-display: optional;font-display: swap;  
最小化动画和过渡：  
避免使用影响布局的动画或过渡，例如导致元素在页面上移动的动画或过渡。  

CLS 与其他指标：  
CLS 与 FID（首次输入延迟）：CLS 测量视觉稳定性，而 FID 测量用户交互和浏览器响应之间的延迟。它们都有助于整体用户体验，但侧重于不同的方面。  

CLS 与 LCP（Largest Contentful Paint）：LCP 测量主要内容何时渲染，侧重于加载速度，而 CLS 测量加载期间内容的稳定性。页面可以具有快速的 LCP，但如果内容发生变化，则 CLS 仍然很差。  

CLS 与 TTI（交互时间）：TTI 衡量页面何时完全互动，而 CLS 衡量页面在加载阶段的稳定性。  
### 5.2.9 LCP
Largest Contentful Paint（LCP）最大内容涂料：用于衡量网页上最大的可见内容元素加载所需的时间。LCP 侧重于视口中可见的最大内容，例如图像、视频或文本块，这对于用户开始与页面互动至关重要。
LCP 以毫秒 （ms） 为单位，可以使用 Google Lighthouse、PageSpeed Insights 和 Chrome DevTools 等工具进行监控。一个好的 LCP 分数通常被认为是 2.5 秒或更短，因为这表明主要内容的加载速度足够快，可以提供积极的用户体验。  

如何提高LCP：  
优化服务器响应时间：  
通过优化服务器性能、使用内容分发网络 （CDN） 和实施缓存策略来缩短服务器响应时间。  
优化图像和视频：  
压缩和调整图像和视频的大小，以确保它们加载速度更快。使用 WebP 等现代格式处理图像，并根据用户的设备调整视频分辨率。  
最小化渲染阻塞资源：  
延迟或异步加载对于呈现主要内容不重要的 JavaScript 和 CSS 文件。优先加载直接影响 LCP 元素的基本 CSS 和 JavaScript 文件。  
对重要资源使用预加载：    
在 HTML 中使用该指令告诉浏览器在加载过程的早期获取重要资源（如主英雄图像）。preload  
改进客户端渲染：  

通过减少呈现页面所需的 JavaScript 数量来优化客户端呈现。请考虑使用服务器端呈现或静态站点生成来更快地交付完全呈现的内容。  
避免延迟加载首屏图像：  

延迟加载有利于提高性能，但请避免延迟加载首屏（即在初始视口中）的图像，因为这可能会延迟 LCP。  

LCP 与其他指标：  
LCP 与 FCP（First Contentful Paint）：FCP 测量的是渲染第一段内容的时间，无论其大小或重要性如何，而 LCP 测量的是渲染最大和最重要的内容的时间。LCP 可以更好地指示主要内容何时准备就绪。  

LCP 与 CLS（累积布局偏移）：LCP 衡量主要内容的加载速度，而 CLS 衡量的是加载过程中页面的视觉稳定性。这两个指标对用户体验都很重要，但侧重于不同的方面。  

LCP 与 TTI（交互时间）：TTI 测量页面何时变得完全互动，而 LCP 测量最大的内容元素何时可见。页面可以具有快速的 LCP，但如果有大量的 JavaScript 处理，则交互速度仍然很慢。  
### 5.2.10 TBT
Total Blocking Time（TBT）总阻塞时间：用于衡量网页的主线程被阻塞且无法响应用户输入的时间量。  
总阻塞时间 （TBT） 衡量的是首次内容绘制 （FCP） 和交互时间 （TTI） 之间的累积时间，在此期间，主线程被阻塞足够长的时间（超过 50 毫秒）以防止页面响应用户输入。换言之，TBT 量化了主线程忙于处理足够长以阻止用户交互的任务的时间。  
TBT 以毫秒 （ms） 为单位。它是通过将 FCP 和 TTI 之间的主线程上所有长任务（执行时间超过 50 毫秒的任务）的持续时间相加来计算的。每个任务的阻塞时间是它超过 50 毫秒的时间量。例如，如果任务耗时 70 毫秒，则阻塞时间为 20 毫秒。  
TBT 的计算方法是将首次内容绘制 （FCP） 和交互时间 （TTI） 之间发生的所有长任务的阻塞时间相加。长任务是指执行时间超过 50 毫秒的任何任务。每个长任务的阻塞时间是它超过 50 毫秒的时间量。    

计算示例：  
假设有三个长期任务：  
需要 80 毫秒的任务：阻塞时间 = 80 - 50 = 30 毫秒  
需要 120 毫秒的任务：阻塞时间 = 120 - 50 = 70 毫秒  
需要 60 毫秒的任务：阻塞时间 = 60 - 50 = 10 毫秒  
TBT 将是这些阻塞时间的总和：三性贸易壁垒=30+70+10=110毫秒  

如何提高技术性贸易壁垒：  
优化 JavaScript：  

最小化和延迟非关键 JavaScript：通过减少页面加载期间执行的 JavaScript 量，您可以降低主线程的负载并减少 TBT。
代码拆分：将 JavaScript 分解为更小的包，这些包可以按需加载，从而减少初始负载并防止长时间的任务。  
减少长时间的任务：  

将长时间运行的 JavaScript 任务分解为更小、更易于管理的部分，使主线程能够保持响应。  
延迟或异步加载资源：  

推迟非必要资源（如第三方脚本或分析）的加载，以确保它们在初始加载期间不会阻塞主线程。  
使用 Web Worker：  

将繁重的计算或后台任务卸载给 Web Worker，这些 Web Worker 在后台运行而不会阻塞主线程。  
优化渲染路径：  

通过优化 CSS 并避免不必要的重排和重绘，减少在布局和渲染上花费的时间。  
TBT 与其他指标：  
TBT 与 FID（首次输入延迟）：FID 测量与页面首次交互期间所经历的延迟，而 TBT 测量主线程被阻止响应 FCP 和 TTI 之间的任何输入的累积时间。技术性贸易壁垒为交互性问题提供了更广泛的视角。  

TBT 与 TTI（交互时间）：TTI 衡量页面何时完全互动并能在 50 毫秒内响应用户输入，而 TBT 量化阻止交互的阻塞时间。提高技术性结核试验可以提高技术转让风险测定。  

TBT 与 LCP（最大内容绘制）：LCP 衡量渲染最大可见内容元素所需的时间，而 TBT 侧重于页面在加载阶段的响应速度。这两个指标都至关重要，但涉及用户体验的不同方面。  
### 5.2.11 MPF
Max Potential FID(MPF)最大潜在 FID:用于估计用户在网页加载阶段尝试与网页交互时可能遇到的最长时间延迟。
最大电位 FID 以毫秒 （ms） 为单位。它是通过分析在首次内容绘制 （FCP） 和交互时间 （TTI） 之间发生的主线程上最长的单个任务来确定的。此指标估计了主线程可能被单个任务阻塞的最长时间，这可能导致响应用户输入的延迟。  

如何提高最大潜在 FID：  
优化 JavaScript 执行：  

最小化和延迟非关键 JavaScript：减少页面加载期间需要执行的 JavaScript 数量有助于降低可能的延迟。
代码拆分：将 JavaScript 分解为更小的块，这些块可以按需加载，从而减小单个任务的大小。  
减少长时间的任务：  

将长任务分解为更小、更易于管理的部分，以确保主线程可以更频繁地将控制权交还给浏览器。  
确定关键任务的优先级：  

确保直接影响用户交互的关键任务得到优先处理，而不太关键的任务则推迟到页面加载之后。  
使用 Web Worker：  

将繁重的计算负担交给 Web Worker，他们可以在后台处理任务，而不会阻塞主线程。  

最大潜在 FID 与其他指标：  
最大潜在 FID 与 FID（首次输入延迟）：FID 衡量与页面首次交互期间所经历的实际延迟，而最大潜在 FID 根据主线程上最长的任务估计可能发生的最严重延迟。  

最大潜在 FID 与 TBT（总阻塞时间）：TBT 衡量主线程被阻塞的总时间，而最大潜在 FID 侧重于单个最长的阻塞任务。  

最大潜在 FID 与 TTI（交互时间）：TTI 衡量页面何时完全交互，而最大潜在 FID 则估计加载过程中可能发生的最坏情况延迟。  

### 5.2.12 TTFB
Time to First Byte（TTFB）首字节时间：用于衡量用户的浏览器在发出 HTTP 请求后从服务器接收第一个字节数据所需的时间。
首字节时间 （TTFB） 是用户浏览器向服务器发送请求到从服务器接收到响应的第一个字节之间的持续时间。它包括 DNS 查找所花费的时间、服务器处理时间和网络延迟。
TTFB 以毫秒 （ms） 为单位。它包含三个主要组成部分：
DNS查找时间：将域名解析为IP地址所需的时间。
连接时间：与服务器建立连接所需的时间。
服务器处理时间：服务器处理请求并开始发送响应所需的时间。
TTFB 是从浏览器发送 HTTP 请求的那一刻开始计算的，直到收到响应的第一个字节。此过程可以分为以下几个阶段：  

DNS查找：浏览器将域名解析为IP地址。  
TCP连接：浏览器与服务器建立TCP连接。  
TLS 握手（如果适用）：如果连接是安全的 （HTTPS），则执行 TLS 握手。  
服务器处理：服务器处理请求并开始生成响应。  
第一个字节接收：浏览器接收服务器响应的第一个字节。  
所有这些步骤的总时间合并为 TTFB。  
如何提高TTFB：  
优化服务器响应时间：  

通过优化数据库查询、使用高效的服务器端代码以及确保服务器不会过载，提高服务器性能。  
使用内容分发网络 （CDN）：  

CDN 将内容缓存在离用户较近的位置，从而减少了传递第一个字节所需的距离和时间。  
优化DNS解析：  

使用速度更快的 DNS 提供商，并考虑通过最小化页面上使用的唯一域数量来减少 DNS 查找。  
减少服务器处理时间：  

简化服务器代码，优化数据库访问，并降低服务器端操作的复杂性。
优化 SSL/TLS 配置：  

确保您的 SSL/TLS 配置已优化，以减少 TLS 握手的开销。  
TTFB 与其他指标：  
TTFB 与 FCP（First Contentful Paint）：TTFB 测量接收响应的第一个字节的时间，而 FCP 测量第一段内容在屏幕上呈现的时间。缓慢的 TTFB 可能会延迟 FCP。  

TTFB 与 LCP（最大内容绘制）：LCP 衡量渲染最大内容元素所需的时间。高 TTFB 可能会延迟 LCP，因为在服务器发送响应之前，主要内容无法开始加载。  

TTFB 与 FID（首次输入延迟）：FID 测量与页面首次交互期间所经历的延迟，而 TTFB 侧重于初始服务器响应时间。两者对于理解网页的响应能力都很重要，但它们衡量性能的不同方面。  
### 5.2.13 RBR
Render Blocking Resources（RBR）渲染阻塞资源：渲染阻塞资源是浏览器必须先加载、解析和执行的文件，通常是 CSS 样式表和 JavaScript 脚本，然后才能呈现网页的内容。这些资源可能会延迟网页对用户可见和交互所需的时间。  
渲染阻塞资源可能会显著影响 Web 性能，尤其是在首次内容绘制 （FCP） 和最大内容绘制 （LCP） 方面。渲染阻塞资源越多，加载时间越长，网页的感知加载时间就越慢。这可能导致糟糕的用户体验、更高的跳出率和更低的搜索引擎排名。  
为什么渲染阻塞资源很重要：  
延迟渲染：  

当浏览器遇到阻止呈现的资源时，它必须停止呈现页面，直到该资源被完全下载和处理。这可能会延迟用户在屏幕上看到第一段内容（第一次内容绘制）的时间点以及页面完全交互的时间。  
用户体验：  

如果用户必须等待可见内容出现或页面变得具有交互性，他们就会认为页面很慢。这可能会导致挫败感和更高的跳出率。  
SEO影响：  

Google 使用 FCP 和 LCP 等性能指标作为其排名算法的一部分。呈现阻塞延迟较高的页面在搜索结果中的排名可能会较低。  
如何优化和减少渲染阻塞资源：  
延迟非关键 JavaScript：  

在标记上使用属性可异步加载 JavaScript 文件。这允许在获取 JavaScript 时解析和呈现 HTML 文档。defer<script>
对 JavaScript 使用 async：  

对不依赖于其他脚本或 HTML 结构的 JavaScript 使用属性。这允许脚本独立于渲染过程下载和执行。async  
内联关键 CSS：  

直接在 HTML 文档中内联关键 CSS。这确保了基本样式立即加载，从而减少了对外部 CSS 文件阻止渲染的需求。<head>  
最小化 CSS：  

减小 CSS 文件的大小和复杂性。删除未使用的 CSS，压缩 CSS 文件，并将 CSS 拆分为更小的特定文件有助于减少渲染阻塞。
异步加载非关键 CSS：  

使用媒体查询（例如，）或使用 JavaScript 动态加载 CSS 文件，以确保非必要的样式不会阻止渲染。media="print"
使用内容分发网络 （CDN）：  

从 CDN 提供 CSS 和 JavaScript 可以减少延迟，使这些资源加载得更快，并减少它们对渲染的影响。    
渲染阻塞资源与其他性能指标：  
渲染阻塞资源与 TTFB（到第一个字节的时间）：TTFB 测量从服务器接收第一个字节所需的时间，而渲染阻塞资源则侧重于在收到初始 HTML 之后但在绘制内容之前的延迟。  

渲染阻塞资源与 FCP（第一个内容绘制）：渲染阻塞资源通过延迟屏幕上显示第一个内容的时间直接影响 FCP。  

渲染阻塞资源与 TTI（交互时间）：虽然渲染阻塞资源会延迟页面的视觉呈现，但它们也可能延迟页面变得交互的时间，尤其是当渲染阻塞资源是影响页面功能的 JavaScript 文件时。  
### 5.2.14 Unused CSS
Unused CSS未使用的 CSS：未使用的 CSS 是指包含在网页中但实际上并未用于设置该页面上任何元素样式的 CSS 代码。这些不必要的代码可能会增加 CSS 文件的大小，减慢页面加载时间，并消耗额外的资源，最终影响网站的性能和用户体验。  
未使用CSS的常见原因：  

全局样式表：在多个页面上使用单个大型样式表可能会导致任何给定页面上的 CSS 未使用，因为并非每个页面都需要所有样式。
框架和库：像 Bootstrap 或 Tailwind 这样的 CSS 框架通常包含大量可能不会在特定项目中使用的样式。  
过度工程：为边缘情况编写 CSS 或面向未来的 CSS，这些 CSS 永远不会应用于当前设计。  
冗余或遗留代码：曾经使用过但不再相关的旧 CSS，但尚未从样式表中删除。  
如何删除未使用的CSS：  
吹扫和缩小：  

PurifyCSS 和 PurgeCSS 是自动扫描 HTML 文件并删除任何未使用的 CSS 的工具。这些工具可以集成到您的构建过程中，以不断优化您的 CSS。  
CSSNano 和其他缩小工具可以通过删除未使用的代码、注释和空格来进一步减小 CSS 的大小。  
拆分 CSS：  

关键 CSS：仅提取和内联渲染首屏内容所需的 CSS，同时异步加载其余样式。  
特定于页面的 CSS：不要在每个页面上加载全局样式表，而是创建特定于页面的 CSS 文件，这些文件仅包含该特定页面所需的样式。  
模块化 CSS：  

将 CSS 分解为更小的模块化部分，可以根据需要包含或排除这些部分。像 CSS-in-JS 或基于组件的 CSS（用于 React 等框架）这样的工具有助于确保只加载特定组件所需的 CSS。  
定期审核：  

定期审核您的 CSS，尤其是在重大设计更改之后，以确保删除任何未使用或冗余的样式。  
删除未使用的 CSS 的好处：  
改进的性能：  

删除未使用的 CSS 可以减小 CSS 文件的大小，从而缩短下载时间、加快渲染速度并提高页面的整体性能。  
更好的用户体验：  

凭借更快的加载时间和更高效的渲染，用户可以体验到更流畅、响应更灵敏的网站。  
更低的带宽成本：  

较小的文件意味着需要传输的数据较少，这可以降低带宽成本，尤其是在高流量站点上。  
更易于维护：  

更精简、更集中的 CSS 文件更易于维护和调试，从而降低了冲突的可能性并使未来的更新更简单。  
未使用的 CSS 与其他 CSS 优化技术：  
未使用的 CSS 与缩小：缩小会从 CSS 中删除不必要的字符（如空格），但不会删除未使用的规则。删除未使用的 CSS 通过消除未应用于任何元素的整个规则更进一步。  

未使用的 CSS 与关键 CSS：关键 CSS 侧重于仅加载首屏内容所需的 CSS，而未使用的 CSS 删除是关于从整个页面中消除所有不相关的样式。  

未使用的 CSS 与延迟加载 CSS：延迟加载 CSS 仅涉及在需要时加载样式（例如，当用户滚动到特定部分时），而删除未使用的 CSS 可确保从一开始就只包含必要的样式。  
### 5.2.15 Unused JavaScript
Unused JavaScript：是指包含在网页中但在用户与该页面交互期间未执行或不需要的 JavaScript 代码。与未使用的 CSS 一样，未使用的 JavaScript 会导致文件大小变大、页面加载时间变慢和性能下降，最终影响用户体验  
对性能的影响：  

文件大小增加：未使用的 JavaScript 会增加需要下载的文件大小，从而导致下载时间更长，尤其是在连接速度较慢的情况下。
较慢的解析和执行：即使不使用代码，浏览器仍然必须解析并可能执行 JavaScript，这可能会减慢渲染过程。  
对关键指标的影响：首次内容绘制 （FCP）、交互时间 （TTI） 和总阻塞时间 （TBT） 等指标可能会因存在未使用的 JavaScript 而受到负面影响，因为它会延迟页面变得交互式所需的时间。  
未使用 JavaScript 的常见原因：  

包括整个库：使用 jQuery、Moment.js 或 Lodash 等大型库，但仅利用其功能的一小部分。  
第三方脚本：包含网页未使用的功能的第三方脚本，例如广告、分析或小组件。  
冗余代码或遗留代码：曾经使用过但不再相关的代码，但尚未从项目中删除。  
全局脚本：在网站的每个页面上加载的 JavaScript 文件，即使某些页面不使用它们。    
如何删除未使用的 JavaScript：  
摇树：  

摇树是现代 JavaScript 打包器（如 Webpack 和 Rollup）中使用的一种技术，可在构建过程中自动删除未使用的代码。它的工作原理是分析代码并消除任何未被引用或使用的部分。  
代码拆分：  

代码拆分涉及将 JavaScript 代码分解为较小的包，这些包仅在需要时加载。这减少了初始加载时间，并确保仅为特定页面或功能执行必要的代码。  
延迟加载：  

延迟加载允许您将 JavaScript 文件的加载推迟到需要它们时。例如，仅当用户与特定功能交互或滚动到页面的特定部分时，才能加载某些脚本。  
删除不必要的库：  

如果您正在使用 jQuery 或 Lodash 等大型库，请考虑它们是否必要。有时，原生 JavaScript 可以替换这些库提供的功能，允许您完全删除它们或用更轻量级的替代品替换它们。  
审计第三方脚本：  

查看您网站上使用的第三方脚本，以确定它们是否必要。如果可能，请使用更轻量级或更集中的替代方法，或将脚本配置为仅加载所需的特定功能。  
优化捆绑包：   

使用 Webpack、Parcel 或 Rollup 等构建工具来捆绑和优化您的 JavaScript。这些工具可以帮助识别和删除未使用的代码，缩小文件，并确保代码尽可能高效。  

未使用的 JavaScript 与其他优化技术的比较：  
未使用的 JavaScript 与缩小：缩小会从 JavaScript 中删除不必要的字符（如空格），但不会删除未使用的代码。删除未使用的 JavaScript 通过消除不需要的整个代码块而更进一步。  

未使用的 JavaScript 与摇树：摇树专门用于在构建过程中删除未使用的代码。这是一种强大的方法，可以自动去除不必要的 JavaScript，作为优化捆绑包的一部分。  

未使用的 JavaScript 与代码拆分：代码拆分的重点是将 JavaScript 划分为更小、更易于管理的包，这些包仅在需要时加载。这通过确保仅下载和执行必要的代码来补充删除未使用的 JavaScript。  
## 5.3 根据指标计算性能，无障碍，最佳做法，SEO分数
### 5.3.1 计算性能分数
计算性能分数并没有一个单一的标准方法，而是根据不同的工具和框架有不同的计算方法。  

一般情况下，性能分数计算可以基于以下几种方法：  
Google Lighthouse 的性能分数：  

Google Lighthouse 是一个广泛使用的工具，提供了一个标准化的性能分数，通常是从 0 到 100 的评分。  
Lighthouse 使用一个加权平均的方式，将多个核心 Web Vitals 和其他性能指标组合成一个分数。  
手动计算加权平均分数：  

你可以基于关键指标的权重手动计算性能分数。每个指标的得分可能基于其原始测量值与预定义的阈值之间的比较。以下是一个简单的示例：  
```python
def calculate_performance_score(fcp, lcp, tti, tbt, cls):
    # 假设的权重（根据Lighthouse的权重）
    fcp_weight = 0.25
    lcp_weight = 0.25
    tti_weight = 0.15
    tbt_weight = 0.25
    cls_weight = 0.10

    # 将每个时间转换为分数，假设分数范围从0到100，越低越好
    fcp_score = max(0, 100 - (fcp / 100))
    lcp_score = max(0, 100 - (lcp / 100))
    tti_score = max(0, 100 - (tti / 100))
    tbt_score = max(0, 100 - (tbt / 100))
    cls_score = max(0, 100 - (cls * 100))

    # 加权平均
    performance_score = (fcp_score * fcp_weight +
                         lcp_score * lcp_weight +
                         tti_score * tti_weight +
                         tbt_score * tbt_weight +
                         cls_score * cls_weight)
    return performance_score

# 示例值（以毫秒为单位）
fcp = 1500  # 1.5秒
lcp = 2500  # 2.5秒
tti = 3000  # 3秒
tbt = 200   # 200毫秒
cls = 0.1   # Cumulative Layout Shift

score = calculate_performance_score(fcp, lcp, tti, tbt, cls)
print(f"Performance Score: {score}")

```
解释  
权重：不同指标对整体用户体验的重要性不同，因此会分配不同的权重。上面的权重是基于 Google Lighthouse 的一个假设分配，你可以根据实际需求进行调整。  

分数计算：每个指标的分数都根据其性能表现计算，得分越高，表示性能越好。然后，将这些分数乘以各自的权重并求和，得到最终的性能分数。  

Lighthouse 评分具体示例  
Lighthouse 实际使用的算法要复杂得多，尤其在考虑 FCP、LCP 等指标时。为了获得与 Lighthouse 类似的分数，最好使用 Lighthouse CLI 或在 Chrome DevTools 中运行 Lighthouse 分析。  
### 5.3.2 无障碍
无障碍（Accessibility）分数通常用于衡量网站或应用程序对残障用户的友好程度，确保所有用户都能够访问和使用网站的内容。像 Google Lighthouse 这样的工具会自动计算无障碍分数，并为开发者提供优化建议。  

无障碍分数的计算方式  
Google Lighthouse 之类的工具通过以下步骤来计算无障碍分数：  
 
审查网页的无障碍特性：  

Lighthouse 运行一系列的测试，检查网页的不同元素是否符合无障碍标准。这些测试包括但不限于以下内容：  
颜色对比：文本与背景之间的对比度是否足够高，以便于阅读。
表单标签：表单输入是否包含适当的标签，以便屏幕阅读器能够正确朗读。  
图像替代文本：图像是否有描述性的替代文本（alt 属性），以便盲人用户能够通过屏幕阅读器了解图像内容。  
页面结构：HTML 标题结构是否逻辑清晰，是否存在跳过内容链接等。
交互元素的焦点状态：交互元素（如按钮、链接等）是否有明确的焦点状态，以便于键盘导航。  
分配每个测试的权重和分数：  

每个无障碍测试根据其重要性被分配一定的权重。Lighthouse 对每个测试结果打分（通常是通过/未通过的二元结果），然后基于权重计算每个测试的得分。  
计算总体无障碍分数：  

总体无障碍分数是根据所有测试得分的加权平均值计算得出的。这个分数通常在 0 到 100 之间，分数越高表示无障碍支持越好。  
```python
def calculate_accessibility_score(tests_results):
    total_weight = sum(weight for _, weight in tests_results)
    total_score = sum(score * weight for score, weight in tests_results)
    
    accessibility_score = (total_score / total_weight) * 100
    return accessibility_score

# 示例测试结果：[(测试得分, 测试权重)]
tests_results = [
    (1, 1.0),  # 通过测试，权重为1.0
    (0.5, 0.5),  # 部分通过测试，权重为0.5
    (1, 2.0),  # 通过测试，权重为2.0
    (0, 1.0),  # 未通过测试，权重为1.0
]

score = calculate_accessibility_score(tests_results)
print(f"Accessibility Score: {score}")

```
### 5.3.3 最佳做法
各方面都最好的状态的时候的分数
### 5.3.4 SEO
SEO（Search Engine Optimization，搜索引擎优化）是指通过优化网站内容和技术结构，提高网站在搜索引擎结果页面（SERP）中的排名，从而增加网站的自然流量的过程。SEO 涉及多个方面，包括关键词优化、内容创建、网站技术优化、用户体验、链接建设等。    
SEO 的主要组成部分  
关键词优化：  

关键词研究：识别用户在搜索引擎中使用的关键词，并将这些关键词自然地融入到网站内容中。  
关键词分布：关键词应当出现在页面的关键位置，如标题、段落、图像的 alt 标签、元描述等。  
内容优化：  

高质量内容：创建对用户有价值的、原创的、高质量内容，回答用户的问题，满足用户的需求。  
内容更新：定期更新网站内容，保持内容的相关性和新鲜度。  
网站技术优化：  

网站速度：提高网站加载速度，确保页面快速响应用户请求。  
移动优化：确保网站在移动设备上的良好表现，这在现代 SEO 中非常重要。  
结构化数据：使用结构化数据标记（如 Schema.org），帮助搜索引擎更好地理解页面内容。  
用户体验：  

易用性：确保网站易于导航，页面设计清晰简洁，提供良好的用户体验。  
安全性：使用 HTTPS 协议，确保用户数据的安全性。  
无障碍性：使网站内容对所有用户都可访问，包括那些有特殊需求的用户。  
外部链接建设：  

外部链接：获得其他高权重网站的链接指向自己的网站，这有助于提高网站的权威性和搜索引擎排名。  
内部链接：合理布局内部链接，增强页面之间的相关性，帮助搜索引擎更好地理解网站结构。  

SEO 分数的计算
SEO 分数通常通过一些工具和方法来评估，它们根据多种因素计算一个综合分数，反映网站的 SEO 优化程度。SEO 分数通常不是由单一标准计算得出，而是通过多个关键因素加权平均得到的。以下是 SEO 分数计算的一些常见方法：  

SEO 分析工具：  

Google Lighthouse：Google Lighthouse 提供了一个 SEO 检查功能，给出一个 SEO 分数（通常是 0 到 100）。Lighthouse 的 SEO 分数基于一系列的测试，涵盖页面的元数据、可爬取性、移动设备友好性等。  
Ahrefs、Moz、SEMrush：这些第三方工具会根据网站的多个 SEO 关键指标（如域名权威性、反向链接数量、关键词排名等）计算 SEO 分数。  
常见的 SEO 检查点：  

页面标题：检查页面是否有唯一且包含关键字的标题标签。  
元描述：检查页面是否有相关且吸引点击的元描述。  
页面加载速度：检测页面加载速度是否满足最佳实践标准。  
移动友好性：确保页面在移动设备上的显示效果良好。  
结构化数据：检查是否使用结构化数据来帮助搜索引擎理解内容。  
反向链接质量：分析反向链接的数量和质量，衡量网站的外部权威性。  
SEO 分数计算示例：  

以下是一个简化的示例，展示如何通过多个因素计算一个基本的 SEO 分数：  
```python
def calculate_seo_score(title_score, meta_description_score, load_speed_score, mobile_friendly_score, backlinks_score):
    # 假设的权重（这些权重可以根据需求调整）
    title_weight = 0.2
    meta_description_weight = 0.2
    load_speed_weight = 0.2
    mobile_friendly_weight = 0.2
    backlinks_weight = 0.2

    # 计算总分
    seo_score = (title_score * title_weight +
                 meta_description_score * meta_description_weight +
                 load_speed_score * load_speed_weight +
                 mobile_friendly_score * mobile_friendly_weight +
                 backlinks_score * backlinks_weight)

    return seo_score

# 示例值，假设每项得分在 0 到 100 之间
title_score = 85
meta_description_score = 90
load_speed_score = 75
mobile_friendly_score = 95
backlinks_score = 80

score = calculate_seo_score(title_score, meta_description_score, load_speed_score, mobile_friendly_score, backlinks_score)
print(f"SEO Score: {score}")

```
提高 SEO 分数的建议  
优化页面内容：  

定期更新并扩展网站内容，确保内容的质量和相关性。  
使用相关关键词，并确保它们自然地出现在内容中。  
提高网站加载速度：  

优化图像大小和格式。  
使用内容分发网络（CDN）加速网站加载。  
最小化 JavaScript 和 CSS 文件。  
确保移动设备友好性：  

使用响应式设计，使网站在各种设备上都有良好的显示效果。  
检查和修复可能影响移动用户体验的元素，如按钮大小、文本可读性等。  
构建高质量的反向链接：  

通过创建有价值的内容吸引其他网站的链接。  
参与行业论坛、博客和社交媒体，增加网站的曝光和链接机会。  
定期使用 SEO 工具进行分析：  

定期使用工具如 Google Search Console、Ahrefs、Moz 等监控网站的 SEO 表现，并根据结果进行优化。  
# 6. 工具
前端自动化测试分析工具：Lighthouse  
全面分析影响页面加载速度的原因;Ping Website Speed Test(缺点是只能测试不需要登录的页面特别适合静态网页)  
PageSpeed Insights:测试页面在移动和桌面设备上的性能  
获取网站性能的可行性深度分析：Chrome DevTools-Performance insights  
前端组件的性能测试：Chrome DevTools，使用方法：https://blog.csdn.net/weixin_56502375/article/details/126898266   

当下组件的耗时没有明确的标准，以使用流畅、无卡顿感为主，如果有性能优化，可用该方法提供性能优化数据  
